;(function(global, factory) {

    /* AMD */ if (typeof define === 'function' && define.amd)
        define(["protobuf"], factory);
    
    /* CommonJS */ else if (typeof require === 'function' && typeof module === 'object' && module && module.exports)
        module.exports = factory(require("protobufjs/runtime"));
    
    /* Global */ else
        global.root = factory(global.protobuf);

})(this, function($runtime) {
    "use strict";

    // Lazily resolved type references
    var $lazyTypes = [];

    // Exported root namespace
    var $root = {};

    /** @alias test */
    $root.test = (function() {

        /** @alias test */
        var test = {};

        /** @alias test.Test */
        test.Test = (function() {

            /**
             * Constructs a new Test.
             * @exports test.Test
             * @constructor
             * @param {function(function, Uint8Array, function)} rpc RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Test(rpc, requestDelimited, responseDelimited) {

                /**
                 * RPC implementation.
                 * @type {function(function, Uint8Array, function)}
                 */
                this.rpc = rpc;

                /**
                 * Whether requests are length-delimited.
                 * @type {boolean}
                 */
                this.requestDelimited = Boolean(requestDelimited);

                /**
                 * Whether responses are length-delimited.
                 * @type {boolean}
                 */
                this.responseDelimited = Boolean(responseDelimited);
            };

            /**
             * Calls Test.
             * @param {test.TestRequest|Object} request TestRequest or plain object
             * @param {function(?Error, test.TestResponse=)} callback Node-style callback called with the error, if any, and TestResponse
             * @returns {undefined}
             */
            Test.prototype.test = function test(request, callback) {
                var requestData;
                try {
                    requestData = (this.requestDelimited && $root.test.TestRequest.encodeDelimited(request) || $root.test.TestRequest.encode(request)).finish();
                } catch (err) {
                    (typeof setImmediate === 'function' && setImmediate || setTimeout)(function() { callback(err); });
                    return;
                }
                var self = this;
                this.rpc(test, requestData, function(err, responseData) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    var response;
                    try {
                        response = self.responseDelimited && $root.test.TestResponse.decodeDelimited(responseData) || $root.test.TestResponse.decode(responseData);
                    } catch (err2) {
                        callback(err2);
                        return;
                    }
                    callback(null, response);
                });
            };

            /**
             * Calls Throw.
             * @param {test.TestRequest|Object} request TestRequest or plain object
             * @param {function(?Error, test.TestResponse=)} callback Node-style callback called with the error, if any, and TestResponse
             * @returns {undefined}
             */
            Test.prototype.throw = function throw(request, callback) {
                var requestData;
                try {
                    requestData = (this.requestDelimited && $root.test.TestRequest.encodeDelimited(request) || $root.test.TestRequest.encode(request)).finish();
                } catch (err) {
                    (typeof setImmediate === 'function' && setImmediate || setTimeout)(function() { callback(err); });
                    return;
                }
                var self = this;
                this.rpc(throw, requestData, function(err, responseData) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    var response;
                    try {
                        response = self.responseDelimited && $root.test.TestResponse.decodeDelimited(responseData) || $root.test.TestResponse.decode(responseData);
                    } catch (err2) {
                        callback(err2);
                        return;
                    }
                    callback(null, response);
                });
            };

            /**
             * Calls NotImplemented.
             * @param {test.TestRequest|Object} request TestRequest or plain object
             * @param {function(?Error, test.TestResponse=)} callback Node-style callback called with the error, if any, and TestResponse
             * @returns {undefined}
             */
            Test.prototype.notImplemented = function notImplemented(request, callback) {
                var requestData;
                try {
                    requestData = (this.requestDelimited && $root.test.TestRequest.encodeDelimited(request) || $root.test.TestRequest.encode(request)).finish();
                } catch (err) {
                    (typeof setImmediate === 'function' && setImmediate || setTimeout)(function() { callback(err); });
                    return;
                }
                var self = this;
                this.rpc(notImplemented, requestData, function(err, responseData) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    var response;
                    try {
                        response = self.responseDelimited && $root.test.TestResponse.decodeDelimited(responseData) || $root.test.TestResponse.decode(responseData);
                    } catch (err2) {
                        callback(err2);
                        return;
                    }
                    callback(null, response);
                });
            };

            /**
             * Calls NotFound.
             * @param {test.TestRequest|Object} request TestRequest or plain object
             * @param {function(?Error, test.TestResponse=)} callback Node-style callback called with the error, if any, and TestResponse
             * @returns {undefined}
             */
            Test.prototype.notFound = function notFound(request, callback) {
                var requestData;
                try {
                    requestData = (this.requestDelimited && $root.test.TestRequest.encodeDelimited(request) || $root.test.TestRequest.encode(request)).finish();
                } catch (err) {
                    (typeof setImmediate === 'function' && setImmediate || setTimeout)(function() { callback(err); });
                    return;
                }
                var self = this;
                this.rpc(notFound, requestData, function(err, responseData) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    var response;
                    try {
                        response = self.responseDelimited && $root.test.TestResponse.decodeDelimited(responseData) || $root.test.TestResponse.decode(responseData);
                    } catch (err2) {
                        callback(err2);
                        return;
                    }
                    callback(null, response);
                });
            };

            return Test;
        })();

        /** @alias test.Stream */
        test.Stream = (function() {

            /**
             * Constructs a new Stream.
             * @exports test.Stream
             * @constructor
             * @param {function(function, Uint8Array, function)} rpc RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function Stream(rpc, requestDelimited, responseDelimited) {

                /**
                 * RPC implementation.
                 * @type {function(function, Uint8Array, function)}
                 */
                this.rpc = rpc;

                /**
                 * Whether requests are length-delimited.
                 * @type {boolean}
                 */
                this.requestDelimited = Boolean(requestDelimited);

                /**
                 * Whether responses are length-delimited.
                 * @type {boolean}
                 */
                this.responseDelimited = Boolean(responseDelimited);
            };

            /**
             * Calls BiStream.
             * @param {test.TestRequest|Object} request TestRequest or plain object
             * @param {function(?Error, test.TestResponse=)} callback Node-style callback called with the error, if any, and TestResponse
             * @returns {undefined}
             */
            Stream.prototype.biStream = function biStream(request, callback) {
                var requestData;
                try {
                    requestData = (this.requestDelimited && $root.test.TestRequest.encodeDelimited(request) || $root.test.TestRequest.encode(request)).finish();
                } catch (err) {
                    (typeof setImmediate === 'function' && setImmediate || setTimeout)(function() { callback(err); });
                    return;
                }
                var self = this;
                this.rpc(biStream, requestData, function(err, responseData) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    var response;
                    try {
                        response = self.responseDelimited && $root.test.TestResponse.decodeDelimited(responseData) || $root.test.TestResponse.decode(responseData);
                    } catch (err2) {
                        callback(err2);
                        return;
                    }
                    callback(null, response);
                });
            };

            /**
             * Calls ResponseStream.
             * @param {test.TestRequest|Object} request TestRequest or plain object
             * @param {function(?Error, test.TestResponse=)} callback Node-style callback called with the error, if any, and TestResponse
             * @returns {undefined}
             */
            Stream.prototype.responseStream = function responseStream(request, callback) {
                var requestData;
                try {
                    requestData = (this.requestDelimited && $root.test.TestRequest.encodeDelimited(request) || $root.test.TestRequest.encode(request)).finish();
                } catch (err) {
                    (typeof setImmediate === 'function' && setImmediate || setTimeout)(function() { callback(err); });
                    return;
                }
                var self = this;
                this.rpc(responseStream, requestData, function(err, responseData) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    var response;
                    try {
                        response = self.responseDelimited && $root.test.TestResponse.decodeDelimited(responseData) || $root.test.TestResponse.decode(responseData);
                    } catch (err2) {
                        callback(err2);
                        return;
                    }
                    callback(null, response);
                });
            };

            /**
             * Calls RequestStream.
             * @param {test.TestRequest|Object} request TestRequest or plain object
             * @param {function(?Error, test.TestResponse=)} callback Node-style callback called with the error, if any, and TestResponse
             * @returns {undefined}
             */
            Stream.prototype.requestStream = function requestStream(request, callback) {
                var requestData;
                try {
                    requestData = (this.requestDelimited && $root.test.TestRequest.encodeDelimited(request) || $root.test.TestRequest.encode(request)).finish();
                } catch (err) {
                    (typeof setImmediate === 'function' && setImmediate || setTimeout)(function() { callback(err); });
                    return;
                }
                var self = this;
                this.rpc(requestStream, requestData, function(err, responseData) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    var response;
                    try {
                        response = self.responseDelimited && $root.test.TestResponse.decodeDelimited(responseData) || $root.test.TestResponse.decode(responseData);
                    } catch (err2) {
                        callback(err2);
                        return;
                    }
                    callback(null, response);
                });
            };

            return Stream;
        })();

        /** @alias test.TestRequest */
        test.TestRequest = (function() {

            /**
             * Constructs a new TestRequest.
             * @exports test.TestRequest
             * @constructor
             * @param {Object} [properties] Properties to set
             */
            function TestRequest(properties) {
                if (properties) {
                    var keys = Object.keys(properties);
                    for (var i = 0; i < keys.length; ++i)
                        this[keys[i]] = properties[keys[i]];
                }
            }

            TestRequest.prototype.value = "";

            /**
             * Encodes the specified TestRequest.
             * @function
             * @param {test.TestRequest|Object} message TestRequest or plain object to encode
             * @param {Writer} [writer] Writer to encode to
             * @returns {Writer} Writer
             */
            TestRequest.encode = (function() {
                /* eslint-disable */
                var Writer = $runtime.Writer;
                var util = $runtime.util;
                var types; $lazyTypes.push(types = [null]);
                return function encode(m,w) {
                    w||(w=Writer())
                    if(m['value']!==undefined&&m['value']!=="")
                        w.tag(1,2).string(m['value'])
                    return w
                }
                /* eslint-enable */
            })();

            /**
             * Encodes the specified TestRequest, length delimited.
             * @param {test.TestRequest|Object} message TestRequest or plain object to encode
             * @param {Writer} [writer] Writer to encode to
             * @returns {Writer} Writer
             */
            TestRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TestRequest from the specified reader or buffer.
             * @function
             * @param {Reader|Uint8Array} readerOrBuffer Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {test.TestRequest} TestRequest
             */
            TestRequest.decode = (function() {
                /* eslint-disable */
                var Reader = $runtime.Reader;
                var util = $runtime.util;
                var types; $lazyTypes.push(types = [null]);
                return function decode(r,l) {
                    r instanceof Reader||(r=Reader(r))
                    var c=l===undefined?r.len:r.pos+l,m=new $root.test.TestRequest
                    while(r.pos<c){
                        var t=r.tag()
                        switch(t.id){
                            case 1:
                                m['value']=r.string()
                                break
                            default:
                                r.skipType(t.wireType)
                                break
                        }
                    }
                    return m
                }
                /* eslint-enable */
            })();

            /**
             * Decodes a TestRequest from the specified reader or buffer, length delimited.
             * @param {Reader|Uint8Array} readerOrBuffer Reader or buffer to decode from
             * @returns {test.TestRequest} TestRequest
             */
            TestRequest.decodeDelimited = function decodeDelimited(readerOrBuffer) {
                readerOrBuffer = readerOrBuffer instanceof Reader ? readerOrBuffer : Reader(readerOrBuffer);
                return this.decode(readerOrBuffer, readerOrBuffer.uint32());
            };

            /**
             * Verifies a TestRequest.
             * @param {test.TestRequest|Object} message TestRequest or plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            TestRequest.verify = (function() {
                /* eslint-disable */
                var types; $lazyTypes.push(types = [null]);
                return function verify(m) {
                    return null
                }
                /* eslint-enable */
            })();

            return TestRequest;
        })();

        /** @alias test.TestResponse */
        test.TestResponse = (function() {

            /**
             * Constructs a new TestResponse.
             * @exports test.TestResponse
             * @constructor
             * @param {Object} [properties] Properties to set
             */
            function TestResponse(properties) {
                if (properties) {
                    var keys = Object.keys(properties);
                    for (var i = 0; i < keys.length; ++i)
                        this[keys[i]] = properties[keys[i]];
                }
            }

            TestResponse.prototype.result = "";

            /**
             * Encodes the specified TestResponse.
             * @function
             * @param {test.TestResponse|Object} message TestResponse or plain object to encode
             * @param {Writer} [writer] Writer to encode to
             * @returns {Writer} Writer
             */
            TestResponse.encode = (function() {
                /* eslint-disable */
                var Writer = $runtime.Writer;
                var util = $runtime.util;
                var types; $lazyTypes.push(types = [null]);
                return function encode(m,w) {
                    w||(w=Writer())
                    if(m['result']!==undefined&&m['result']!=="")
                        w.tag(1,2).string(m['result'])
                    return w
                }
                /* eslint-enable */
            })();

            /**
             * Encodes the specified TestResponse, length delimited.
             * @param {test.TestResponse|Object} message TestResponse or plain object to encode
             * @param {Writer} [writer] Writer to encode to
             * @returns {Writer} Writer
             */
            TestResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TestResponse from the specified reader or buffer.
             * @function
             * @param {Reader|Uint8Array} readerOrBuffer Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {test.TestResponse} TestResponse
             */
            TestResponse.decode = (function() {
                /* eslint-disable */
                var Reader = $runtime.Reader;
                var util = $runtime.util;
                var types; $lazyTypes.push(types = [null]);
                return function decode(r,l) {
                    r instanceof Reader||(r=Reader(r))
                    var c=l===undefined?r.len:r.pos+l,m=new $root.test.TestResponse
                    while(r.pos<c){
                        var t=r.tag()
                        switch(t.id){
                            case 1:
                                m['result']=r.string()
                                break
                            default:
                                r.skipType(t.wireType)
                                break
                        }
                    }
                    return m
                }
                /* eslint-enable */
            })();

            /**
             * Decodes a TestResponse from the specified reader or buffer, length delimited.
             * @param {Reader|Uint8Array} readerOrBuffer Reader or buffer to decode from
             * @returns {test.TestResponse} TestResponse
             */
            TestResponse.decodeDelimited = function decodeDelimited(readerOrBuffer) {
                readerOrBuffer = readerOrBuffer instanceof Reader ? readerOrBuffer : Reader(readerOrBuffer);
                return this.decode(readerOrBuffer, readerOrBuffer.uint32());
            };

            /**
             * Verifies a TestResponse.
             * @param {test.TestResponse|Object} message TestResponse or plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            TestResponse.verify = (function() {
                /* eslint-disable */
                var types; $lazyTypes.push(types = [null]);
                return function verify(m) {
                    return null
                }
                /* eslint-enable */
            })();

            return TestResponse;
        })();

        /** @alias test.TestEvent */
        test.TestEvent = (function() {

            /**
             * Constructs a new TestEvent.
             * @exports test.TestEvent
             * @constructor
             * @param {Object} [properties] Properties to set
             */
            function TestEvent(properties) {
                if (properties) {
                    var keys = Object.keys(properties);
                    for (var i = 0; i < keys.length; ++i)
                        this[keys[i]] = properties[keys[i]];
                }
            }

            TestEvent.prototype.value = "";
            TestEvent.prototype.count = 0;

            /**
             * Encodes the specified TestEvent.
             * @function
             * @param {test.TestEvent|Object} message TestEvent or plain object to encode
             * @param {Writer} [writer] Writer to encode to
             * @returns {Writer} Writer
             */
            TestEvent.encode = (function() {
                /* eslint-disable */
                var Writer = $runtime.Writer;
                var util = $runtime.util;
                var types; $lazyTypes.push(types = [null,null,null]);
                return function encode(m,w) {
                    w||(w=Writer())
                    if(m['value']!==undefined&&m['value']!=="")
                        w.tag(1,2).string(m['value'])
                    if(m['count']!==undefined&&m['count']!==0)
                        w.tag(2,0).int32(m['count'])
                    if(m['test']){
                        w.fork()
                        for(var i=0,ks=Object.keys(m['test']);i<ks.length;++i){
                            w.tag(1,0).int64(ks[i])
                            w.tag(2,0).int64(m['test'][ks[i]])
                        }
                        w.len&&w.ldelim(3)||w.reset()
                    }
                    return w
                }
                /* eslint-enable */
            })();

            /**
             * Encodes the specified TestEvent, length delimited.
             * @param {test.TestEvent|Object} message TestEvent or plain object to encode
             * @param {Writer} [writer] Writer to encode to
             * @returns {Writer} Writer
             */
            TestEvent.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TestEvent from the specified reader or buffer.
             * @function
             * @param {Reader|Uint8Array} readerOrBuffer Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {test.TestEvent} TestEvent
             */
            TestEvent.decode = (function() {
                /* eslint-disable */
                var Reader = $runtime.Reader;
                var util = $runtime.util;
                var types; $lazyTypes.push(types = [null,null,null]);
                return function decode(r,l) {
                    r instanceof Reader||(r=Reader(r))
                    var c=l===undefined?r.len:r.pos+l,m=new $root.test.TestEvent
                    while(r.pos<c){
                        var t=r.tag()
                        switch(t.id){
                            case 1:
                                m['value']=r.string()
                                break
                            case 2:
                                m['count']=r.int32()
                                break
                            case 3:
                                var n=r.uint32(),o={}
                                if(n){
                                    n+=r.pos
                                    var k=[],v=[]
                                    while(r.pos<n){
                                        if(r.tag().id===1)
                                            k[k.length]=r.int64()
                                        else
                                            v[v.length]=r.int64()
                                    }
                                    for(var i=0;i<k.length;++i)
                                        o[typeof(k[i])==='object'?util.longToHash(k[i]):k[i]]=v[i]
                                }
                                m['test']=o
                                break
                            default:
                                r.skipType(t.wireType)
                                break
                        }
                    }
                    return m
                }
                /* eslint-enable */
            })();

            /**
             * Decodes a TestEvent from the specified reader or buffer, length delimited.
             * @param {Reader|Uint8Array} readerOrBuffer Reader or buffer to decode from
             * @returns {test.TestEvent} TestEvent
             */
            TestEvent.decodeDelimited = function decodeDelimited(readerOrBuffer) {
                readerOrBuffer = readerOrBuffer instanceof Reader ? readerOrBuffer : Reader(readerOrBuffer);
                return this.decode(readerOrBuffer, readerOrBuffer.uint32());
            };

            /**
             * Verifies a TestEvent.
             * @param {test.TestEvent|Object} message TestEvent or plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            TestEvent.verify = (function() {
                /* eslint-disable */
                var types; $lazyTypes.push(types = [null,null,null]);
                return function verify(m) {
                    return null
                }
                /* eslint-enable */
            })();

            return TestEvent;
        })();

        /** @alias test.ExtendMe */
        test.ExtendMe = (function() {

            /**
             * Constructs a new ExtendMe.
             * @exports test.ExtendMe
             * @constructor
             * @param {Object} [properties] Properties to set
             */
            function ExtendMe(properties) {
                if (properties) {
                    var keys = Object.keys(properties);
                    for (var i = 0; i < keys.length; ++i)
                        this[keys[i]] = properties[keys[i]];
                }
            }

            ExtendMe.prototype.bar = 0;

            /**
             * Encodes the specified ExtendMe.
             * @function
             * @param {test.ExtendMe|Object} message ExtendMe or plain object to encode
             * @param {Writer} [writer] Writer to encode to
             * @returns {Writer} Writer
             */
            ExtendMe.encode = (function() {
                /* eslint-disable */
                var Writer = $runtime.Writer;
                var util = $runtime.util;
                var types; $lazyTypes.push(types = [null]);
                return function encode(m,w) {
                    w||(w=Writer())
                    if(m['bar']!==undefined&&m['bar']!==0)
                        w.tag(126,0).int32(m['bar'])
                    return w
                }
                /* eslint-enable */
            })();

            /**
             * Encodes the specified ExtendMe, length delimited.
             * @param {test.ExtendMe|Object} message ExtendMe or plain object to encode
             * @param {Writer} [writer] Writer to encode to
             * @returns {Writer} Writer
             */
            ExtendMe.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ExtendMe from the specified reader or buffer.
             * @function
             * @param {Reader|Uint8Array} readerOrBuffer Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {test.ExtendMe} ExtendMe
             */
            ExtendMe.decode = (function() {
                /* eslint-disable */
                var Reader = $runtime.Reader;
                var util = $runtime.util;
                var types; $lazyTypes.push(types = [null]);
                return function decode(r,l) {
                    r instanceof Reader||(r=Reader(r))
                    var c=l===undefined?r.len:r.pos+l,m=new $root.test.ExtendMe
                    while(r.pos<c){
                        var t=r.tag()
                        switch(t.id){
                            case 126:
                                m['bar']=r.int32()
                                break
                            default:
                                r.skipType(t.wireType)
                                break
                        }
                    }
                    return m
                }
                /* eslint-enable */
            })();

            /**
             * Decodes a ExtendMe from the specified reader or buffer, length delimited.
             * @param {Reader|Uint8Array} readerOrBuffer Reader or buffer to decode from
             * @returns {test.ExtendMe} ExtendMe
             */
            ExtendMe.decodeDelimited = function decodeDelimited(readerOrBuffer) {
                readerOrBuffer = readerOrBuffer instanceof Reader ? readerOrBuffer : Reader(readerOrBuffer);
                return this.decode(readerOrBuffer, readerOrBuffer.uint32());
            };

            /**
             * Verifies a ExtendMe.
             * @param {test.ExtendMe|Object} message ExtendMe or plain object to verify
             * @returns {?string} `null` if valid, otherwise the reason why it is not
             */
            ExtendMe.verify = (function() {
                /* eslint-disable */
                var types; $lazyTypes.push(types = [null]);
                return function verify(m) {
                    return null
                }
                /* eslint-enable */
            })();

            return ExtendMe;
        })();

        return test;
    })();

    // Resolve lazy types
    $lazyTypes.forEach(function(types) {
        types.forEach(function(path, i) {
            if (!path)
                return;
            path = path.split('.');
            var ptr = $root;
            while (path.length)
                ptr = ptr[path.shift()];
            types[i] = ptr;
        });
    });

    return $root;
});
